// ======================================================================
// \title  DataPacketSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for DataPacket struct
// ======================================================================

#include "cstdio"
#include "cstring"

#include "DataPacket/DataPacketSerializableAc.hpp"
#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"

namespace OBC_project {

  // ----------------------------------------------------------------------
  // StringSize10 class
  // ----------------------------------------------------------------------

  DataPacket::StringSize10 ::
    StringSize10() :
      StringBase()
  {
    this->m_buf[0] = 0;
  }

  DataPacket::StringSize10 ::
    StringSize10(const char* src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src, sizeof(this->m_buf));
  }

  DataPacket::StringSize10 ::
    StringSize10(const Fw::StringBase& src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
  }

  DataPacket::StringSize10 ::
    StringSize10(const StringSize10& src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
  }

  DataPacket::StringSize10 ::
    ~StringSize10()
  {

  }

  DataPacket::StringSize10& DataPacket::StringSize10 ::
    operator=(const StringSize10& other)
  {
    if (this == &other) {
      return *this;
    }

    Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
    return *this;
  }

  DataPacket::StringSize10& DataPacket::StringSize10 ::
    operator=(const Fw::StringBase& other)
  {
    if (this == &other) {
      return *this;
    }

    Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
    return *this;
  }

  DataPacket::StringSize10& DataPacket::StringSize10 ::
    operator=(const char* other)
  {
    Fw::StringUtils::string_copy(this->m_buf, other, sizeof(this->m_buf));
    return *this;
  }

  const char* DataPacket::StringSize10 ::
    toChar() const
  {
    return this->m_buf;
  }

  NATIVE_UINT_TYPE DataPacket::StringSize10 ::
    getCapacity() const
  {
    return sizeof(this->m_buf);
  }

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  DataPacket ::
    DataPacket() :
      Serializable(),
      destination(""),
      message("")
  {

  }

  DataPacket ::
    DataPacket(
        const StringSize10& destination,
        const StringSize10& message
    ) :
      Serializable(),
      destination(destination),
      message(message)
  {

  }

  DataPacket ::
    DataPacket(const DataPacket& obj) :
      Serializable(),
      destination(obj.destination),
      message(obj.message)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  DataPacket& DataPacket ::
    operator=(const DataPacket& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.destination, obj.message);
    return *this;
  }

  bool DataPacket ::
    operator==(const DataPacket& obj) const
  {
    return (
      (this->destination == obj.destination) &&
      (this->message == obj.message)
    );
  }

  bool DataPacket ::
    operator!=(const DataPacket& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const DataPacket& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus DataPacket ::
    serialize(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status;

    status = buffer.serialize(this->destination);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->message);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus DataPacket ::
    deserialize(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status;

    status = buffer.deserialize(this->destination);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->message);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

#if FW_SERIALIZABLE_TO_STRING || BUILD_UT

  void DataPacket ::
    toString(Fw::StringBase& sb) const
  {
    static const char* formatString =
      "( "
      "destination = %s, "
      "message = %s"
      " )";

    char outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE];
    (void) snprintf(
      outputString,
      FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE,
      formatString,
      this->destination.toChar(),
      this->message.toChar()
    );

    outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE-1] = 0; // NULL terminate
    sb = outputString;
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void DataPacket ::
    set(
        const StringSize10& destination,
        const StringSize10& message
    )
  {
    this->destination = destination;
    this->message = message;
  }

  void DataPacket ::
    setdestination(const StringSize10& destination)
  {
    this->destination = destination;
  }

  void DataPacket ::
    setmessage(const StringSize10& message)
  {
    this->message = message;
  }

}
